"""
Example script for the restrained ensemble simulation.
It is a modification of a standard script for running an OpenMM simulation generated by CHARMM-GUI (http://www.charmm-gui.org/) and utilize mpi4py for running multiple copies of the system.
"""

from __future__ import print_function
import argparse
import sys
import os

from omm_readinputs import *
from omm_readparams import *
from omm_vfswitch import *
from omm_barostat import *
from omm_restraints import *
from omm_rewrap import *

from simtk.unit import *
from simtk.openmm import *
from simtk.openmm.app import *

from REplugin import REForce

from mpi4py import MPI
import numpy

# Configure the MPI environment
comm = MPI.COMM_WORLD	# Communication group
size = comm.Get_size()	# Total number of MPI ranks used
rank = comm.Get_rank()	# Index of the current rank
if (rank==0):
    print("This simulation will run with %s ranks." % size)
print("Hello from rank %s" % rank)

# Parse command line arguments
parser = argparse.ArgumentParser()
parser.add_argument('-i', dest='inpfile', help='Input parameter file', required=True)
parser.add_argument('-p', dest='psffile', help='Input CHARMM PSF file', required=True)
parser.add_argument('-c', dest='crdfile', help='Input CHARMM CRD file', required=True)
parser.add_argument('-t', dest='toppar', help='Input CHARMM-GUI toppar stream file', required=True)
parser.add_argument('-b', dest='sysinfo', help='Input CHARMM-GUI sysinfo stream file (optional)', default=None)
parser.add_argument('-icrst', metavar='RSTFILE', dest='icrst', help='Input CHARMM RST file (optional)', default=None)
parser.add_argument('-irst', metavar='RSTFILE', dest='irst', help='Input restart file (optional)', default=None)
parser.add_argument('-ichk', metavar='CHKFILE', dest='ichk', help='Input checkpoint file (optional)', default=None)
parser.add_argument('-orst', metavar='RSTFILE', dest='orst', help='Output restart file (optional)', default=None)
parser.add_argument('-ochk', metavar='CHKFILE', dest='ochk', help='Output checkpoint file (optional)', default=None)
parser.add_argument('-odcd', metavar='DCDFILE', dest='odcd', help='Output trajectory file (optional)', default=None)
parser.add_argument('-rewrap', dest='rewrap', help='Re-wrap the coordinates in a molecular basis (optional)', action='store_true', default=False)
args = parser.parse_args()

# Load parameters
print("Loading parameters")
inputs = read_inputs(args.inpfile)
params = read_params(args.toppar)
psf = read_psf(args.psffile)
crd = read_crd(args.crdfile)
if args.sysinfo:
    psf = read_box(psf, args.sysinfo)
else:
    psf = gen_box(psf, crd)
    
# Build system
system = psf.createSystem(params, nonbondedMethod=inputs.coulomb,
                          nonbondedCutoff=inputs.r_off*nanometers,
                          constraints=inputs.cons,
                          ewaldErrorTolerance=inputs.ewald_Tol)

if inputs.vdw == 'Force-switch': system = vfswitch(system, psf, inputs)
if inputs.pcouple == 'yes':      system = barostat(system, inputs)
if inputs.rest == 'yes':         system = restraints(system, crd, inputs)

####################
# Restrining force #
####################
# Check ./openmmapi/include/REForce.h for a full list of C++ functions for the RE force object. Corresponding python-wrapped functions could be found at ./python/REplugin.i

# Create a force object. We will customize it below.
saxs_force = REForce()

# Set the RE force parameters
# setAllParams(T, k_xray, k_neutron, w_dens, w_dens_sqr, tau, cutoff)
# T - Temperature in K
# k_xray - X-ray force constant
# k_neutron - neutron force constant
# w_dens - average bulk water number density in 1/nm
# w_dens_sqr - average water number density squared <w_dens^2> in 1/nm^2
# tau - the parameter used for a gradual introduction of the biasing force in ps. First tau ps the force is 0.0, then it is gradually increased and after 2*tau ps the force is fully introduced.
# cutoff - the distance (nm) from the bilayer center (origin) within which atoms are subject to the refining force. It should be large enough to include water layer near the lipid headgroups. 
saxs_force.setAllParams(298.0, 2.5e-1, 2.5e-1, 33.6443295866206, 1131.960362492455, 10.0, 6.0)
if (rank==0):
    saxs_force.setWriteOutFF(True)	# Write output only from the first rank. By default is set to False, which implies no form factor information output.
    saxs_force.setOutPrefix("%s" % rank)# Output prefix is the rank number
n_steps_couple = 100	    		# Recalculate form factor every n_steps_couple steps
n_iterations_rescale = 1000 		# Rescale the experimental data to the form factor every n_iterations_rescale*n_steps_couple steps
saxs_force.setCoupleSteps(n_steps_couple)

# Set up atom names. We use them to determine the scattering strength.
# The full list of atom names and scattering parameters can be found in platforms/cuda/src/CudaFFMaps.cpp. If you use atoms not defined there, feel free to add them.
# Here we use for_names.dat file that contains only lines with atom numbers, names, etc. The fourth column of this file contains the atom names.
# We also set all partial charges to 0.0. If you have a piece of good information on partial charges of the atoms, you can add them here.
file_names = open("./for_names.dat", "r")
for line in file_names:
    saxs_force.addName(str(line.split()[3]))
    saxs_force.addCharge(0.0)
file_names.close()

# Add the atoms that are water. We use this information for a different way of water X-ray scattering strength calculation. See the paper for the details.
# in_water.dat contains indices of the water atoms one per line.
file_water = open("./in_water.dat", "r")
for line in file_water:
    saxs_force.addParticleWater(int(line) - 1)	# Atom index in in_water.dat starts from 1, but atom names start from 0, so -1 will fix it.
						# This is an artifact of the way we generated the in_water.dat file. We used pdb file which counts atoms from 1, not from 0 as we do.
file_water.close()

# Add atoms on which force will act. In most of the cases this would be all the atoms in the system, but sometimes you might want to use only heavy atoms for the biasing force or exclude water, etc.
file_atom = open("./in_atoms.dat", "r")
for line in file_atom:
    saxs_force.addParticle(int(line) - 1)	# Atom index in in_atoms.dat starts from 1, but atom names start from 0, so -1 will fix it.
						# This is an artifact of the way we generated the in_atoms.dat file. We used pdb file which counts atoms from 1, not from 0 as we do.
file_atom.close()

# Add atoms that are used in bilayer center of mass calculation (origin)
file_origin = open("./in_orig.dat", "r")
for line in file_origin:
    saxs_force.addParticleOrigin(int(line) - 1) # Atom index in in_orig.dat starts from 1, but atom names start from 0, so -1 will fix it.
						# This is an artifact of the way we generated the in_orig.dat file. We used pdb file which counts atoms from 1, not from 0 as we do.
file_origin.close()

# Add atoms that are ions
file_ions = open("./in_ions.dat", "r")
for line in file_ions:
    saxs_force.addParticleIon(int(line) - 1)	# Atom index in_ions.dat starts from 1, but atom names start from 0, so -1 will fix it.
						# This is an artifact of the way we generated the in_ions.dat file. We used pdb file which counts atoms from 1, not from 0 as we do.
file_ions.close()

# Add atoms that are exchangeable hydrogens
file_exch_h = open("./in_exch_h.dat", "r")
for line in file_exch_h:
    saxs_force.addParticleExchH(int(line) - 1)  # Atom index in_exch_hydrogen.dat starts from 1, but atom names start from 0, so -1 will fix it.
						# This is an artifact of the way we generated the in_exch_hydrogen.dat file. We used pdb file which counts atoms from 1, not from 0 as we do.
file_exch_h.close()

# Add experimental data points
num_q_xray_total = 0
num_q_neutron_total = 0

# X-ray
F_xray = []
q_xray = []
delta_F_xray = []
# Read the file with experimental data. The file contain lines with q values, form factor and corresponding uncertainty.
file_ff_xray = open("./POPS_ULV@25Cin0D.xff")
for line in file_ff_xray:
    q_xray.append(float(line.split()[0])*10.0)		# We work in nm^-1, but the data is in A^-1, so convert to nm^-1
    F_xray.append(float(line.split()[1]))
    delta_F_xray.append(float(line.split()[2]))
file_ff_xray.close()
num_q_xray_total += len(q_xray)
# addExpFF(F_xray, delta_F_xray, q_xray, is_neutron, d_part)
# F_xray - array of X-ray data points
# delta_F_xray - array of corresponding uncertainty values
# q_xray - array of scattering vector values
# is_neutron - defines if the data set correspond to neutron or X-ray data
# d_part - fraction of D2O in the solvent. Relevant only for the neutron data.
saxs_force.addExpFF(F_xray, delta_F_xray, q_xray, bool(False), float(0.0))

print("Number of X-ray data points: " + str(num_q_xray_total))

# Neutron
F_neutron = []
q_neutron = []
delta_F_neutron = []

file_ff_neutron = open("./POPS_ULV@25Cin100D.nff")
for line in file_ff_neutron:
    q_neutron.append(float(line.split()[0])*10.0)	# We work in nm^-1, but the data is in A^-1, so convert to nm^-1
    F_neutron.append(float(line.split()[1]))
    delta_F_neutron.append(float(line.split()[2]))
file_ff_neutron.close()
num_q_neutron_total += len(q_neutron)
saxs_force.addExpFF(F_neutron, delta_F_neutron, q_neutron, bool(True), float(1.0))

F_neutron = []
q_neutron = []
delta_F_neutron = []

file_ff_neutron = open("./POPS_ULV@25Cin75D.nff")
for line in file_ff_neutron:
    q_neutron.append(float(line.split()[0])*10.0)	# We work in nm^-1, but the data is in A^-1, so convert to nm^-1
    F_neutron.append(float(line.split()[1]))
    delta_F_neutron.append(float(line.split()[2]))
file_ff_neutron.close()
num_q_neutron_total += len(q_neutron)
saxs_force.addExpFF(F_neutron, delta_F_neutron, q_neutron, bool(True), float(0.75))

file_ff_neutron = open("./POPS_ULV@25Cin50D.nff")
for line in file_ff_neutron:
    q_neutron.append(float(line.split()[0])*10.0)	# We work in nm^-1, but the data is in A^-1, so convert to nm^-1
    F_neutron.append(float(line.split()[1]))
    delta_F_neutron.append(float(line.split()[2]))
file_ff_neutron.close()
num_q_neutron_total += len(q_neutron)
saxs_force.addExpFF(F_neutron, delta_F_neutron, q_neutron, bool(True), float(0.5))

print("Number of neutron data points: "+ str(num_q_neutron_total))
# All the properties of the biasing force are now set, now add RE force to the system.
system.addForce(saxs_force)

# Set num_q values to 2 if no exp data is given. That is necessary for the proper handling inside the force implementation.
if (num_q_xray_total==0):
    num_q_xray_total=2
if (num_q_neutron_total==0):
    num_q_neutron_total=2

###########################

# Set integrator
integrator = LangevinIntegrator(inputs.temp*kelvin, inputs.fric_coeff/picosecond, inputs.dt*picoseconds)

# Set platform
platform = Platform.getPlatformByName('CUDA')
dev_index = int(rank % 4)
print('Rank ' + str(rank) +' dev_index ' + str(dev_index))
prop = dict(CudaPrecision='mixed', DeviceIndex='%s' % dev_index)

# Build simulation context
simulation = Simulation(psf.topology, system, integrator, platform, prop)
simulation.context.setPositions(crd.positions)

# Read input restart or checkpoint files.
# In this example we don't use this mechanism. We explicitly specify the name of the restart file below.
if args.icrst:
    charmm_rst = read_charmm_rst(args.icrst)
    simulation.context.setPositions(charmm_rst.positions)
    simulation.context.setVelocities(charmm_rst.velocities)
    simulation.context.setPeriodicBoxVectors(charmm_rst.box[0], charmm_rst.box[1], charmm_rst.box[2])
if args.irst:
    with open(args.irst, 'r') as f:
        simulation.context.setState(XmlSerializer.deserialize(f.read()))
if args.ichk:
    with open(args.ichk, 'rb') as f:
        simulation.context.loadCheckpoint(f.read())

# Restart from a restart file
# All system copies use the same restart file - start from the same configuration.
with open('restart.rst', 'r') as f:
    simulation.context.setState(XmlSerializer.deserialize(f.read()))
# If we already have separate configuration for each copy use the commented code below instead.
# Each system copy (rank) will use its own restart file.
#
#with open('restart%s.rst' % rank, 'r') as f:
#    simulation.context.setState(XmlSerializer.deserialize(f.read()))
#

# Re-wrap
if args.rewrap:
    simulation = rewrap(simulation)

# Calculate initial system energy
print("\nInitial system energy")
print(simulation.context.getState(getEnergy=True).getPotentialEnergy())

# Energy minimization
if inputs.mini_nstep > 0:
    print("\nEnergy minimization: %s steps" % inputs.mini_nstep)
    simulation.minimizeEnergy(tolerance=inputs.mini_Tol*kilojoule/mole, maxIterations=inputs.mini_nstep)
    print(simulation.context.getState(getEnergy=True).getPotentialEnergy())

# Generate initial velocities
if inputs.gen_vel == 'yes':
    print("\nGenerate initial velocities")
    if inputs.gen_seed:
        simulation.context.setVelocitiesToTemperature(inputs.gen_temp, inputs.gen_seed)
    else:
        simulation.context.setVelocitiesToTemperature(inputs.gen_temp)

# Output dcd trajectory
if not args.odcd: args.odcd = 'output%s.dcd' % rank
simulation.reporters.append(DCDReporter(args.odcd, inputs.nstdcd))

simulation.reporters.append(
        StateDataReporter(sys.stdout, inputs.nstout, step=True, time=True, potentialEnergy=True, temperature=True, progress=True,
                          remainingTime=True, speed=True, totalSteps=inputs.nstep, separator='\t')
    )

# Main run cycle
# Each cycle is composed of the following steps:
# - Calculating the form factor components for each system
# - Communicating and averaging the form factor components over multiple copies of the system (ranks)
# - Rescaling experimental data to the simulated form factors if necessary
# - Performing n_steps_couple steps of MD with a newly updated form factor value
# - Output restart files if necessary
for i in range(inputs.nstep // n_steps_couple):
    # First, communicate and average form factor components between different copies of the system (ranks)
    # Copy local form factor components from the kernel implementation to the force object
    saxs_force.getParametersFromContext(simulation.context)
    # Get the form factor values from the force object
    FFComponents = saxs_force.getAComponents()
    # Convert them to numpy arrays
    A_real_xray_local=numpy.asarray(FFComponents[0])
    A_complex_xray_local=numpy.asarray(FFComponents[1])
    A_sqr_xray_local=numpy.asarray(FFComponents[2])
    A_real_neutron_local=numpy.asarray(FFComponents[3])
    A_complex_neutron_local=numpy.asarray(FFComponents[4])
    A_sqr_neutron_local=numpy.asarray(FFComponents[5])
    B_real_xray_local=numpy.asarray(FFComponents[6])
    B_sqr_xray_local=numpy.asarray(FFComponents[7])
    B_real_neutron_local=numpy.asarray(FFComponents[8])
    B_sqr_neutron_local=numpy.asarray(FFComponents[9])

    # Normalize local values of the form factor components by the number of system copies
    for j in range(num_q_xray_total):
        A_real_xray_local[j]/=size
        A_complex_xray_local[j]/=size
        A_sqr_xray_local[j]/=size
        B_real_xray_local[j]/=size
        B_sqr_xray_local[j]/=size
    for j in range(num_q_neutron_total):
        A_real_neutron_local[j]/=size
        A_complex_neutron_local[j]/=size
        A_sqr_neutron_local[j]/=size
        B_real_neutron_local[j]/=size
        B_sqr_neutron_local[j]/=size

    # Initialize numpy arrays for the averaged form factor components
    A_real_xray=numpy.zeros(num_q_xray_total,dtype=numpy.double)
    A_complex_xray=numpy.zeros(num_q_xray_total,dtype=numpy.double)
    A_sqr_xray=numpy.zeros(num_q_xray_total,dtype=numpy.double)
    B_real_xray=numpy.zeros(num_q_xray_total,dtype=numpy.double)
    B_sqr_xray=numpy.zeros(num_q_xray_total,dtype=numpy.double)
    A_real_neutron=numpy.zeros(num_q_neutron_total,dtype=numpy.double)
    A_complex_neutron=numpy.zeros(num_q_neutron_total,dtype=numpy.double)
    A_sqr_neutron=numpy.zeros(num_q_neutron_total,dtype=numpy.double)
    B_real_neutron=numpy.zeros(num_q_neutron_total,dtype=numpy.double)
    B_sqr_neutron=numpy.zeros(num_q_neutron_total,dtype=numpy.double)

    # Communicate local form factor components between different ranks
    comm.Allreduce([A_real_xray_local, MPI.DOUBLE], [A_real_xray, MPI.DOUBLE])
    comm.Allreduce([A_complex_xray_local, MPI.DOUBLE], [A_complex_xray, MPI.DOUBLE])
    comm.Allreduce([A_sqr_xray_local, MPI.DOUBLE], [A_sqr_xray, MPI.DOUBLE])
    comm.Allreduce([B_real_xray_local, MPI.DOUBLE], [B_real_xray, MPI.DOUBLE])
    comm.Allreduce([B_sqr_xray_local, MPI.DOUBLE], [B_sqr_xray, MPI.DOUBLE])
    comm.Allreduce([A_real_neutron_local, MPI.DOUBLE], [A_real_neutron, MPI.DOUBLE])
    comm.Allreduce([A_complex_neutron_local, MPI.DOUBLE], [A_complex_neutron, MPI.DOUBLE])
    comm.Allreduce([A_sqr_neutron_local, MPI.DOUBLE], [A_sqr_neutron, MPI.DOUBLE])
    comm.Allreduce([B_real_neutron_local, MPI.DOUBLE], [B_real_neutron, MPI.DOUBLE])
    comm.Allreduce([B_sqr_neutron_local, MPI.DOUBLE], [B_sqr_neutron, MPI.DOUBLE])

    # Copy averaged (over the system copies) values of the form factor components back to the force object
    saxs_force.setAComponents(A_real_xray, A_complex_xray, A_sqr_xray, A_real_neutron, A_complex_neutron, A_sqr_neutron, B_real_xray, B_sqr_xray, B_real_neutron, B_sqr_neutron)
    # Calculate the current value of the form factor from its averaged components and update the values in the kernel implementation.
    # We can calculate the form factor from its components on the host CPU and then copy resulting FF values to GPU (default behavior of updateParametersInContext()), or copy the form factor components
    # to GPU and then calculate the form factor on GPU (need to add the flag to updateParametersInContext(), e.g. updateParametersInContext(simulation.context, True)).
    # The benefit of calculating the form factor on GPU or CPU depends on the total number of experimental points.
    # updateParametersInContext(context, on_gpu)
    saxs_force.updateParametersInContext(simulation.context, False)

    # Rescale experimental data every n_iterations_rescale*n_steps_couple steps
    if (i%n_iterations_rescale == 0):
        saxs_force.rescaleExpFInContext(simulation.context)

    # Run n_steps_couple steps of MD
    simulation.step(n_steps_couple)

    # Write a restart file
    if (i%500 == 0):
        state = simulation.context.getState( getPositions=True, getVelocities=True )
        with open('restart%s.rst' % rank, 'w') as f:
            f.write(XmlSerializer.serialize(state))
        # If the simulation crash or killed during the restart file output, we still have the backup
        with open('restart_backup%s.rst' % rank, 'w') as f:
            f.write(XmlSerializer.serialize(state))
